/*
* 变量提升：
*   1. 作用域开辟后，js代码执行之前，对带var和function的进行预解析；带var的是只声明不定义，而带function的既声明又定义；（声明：告诉浏览器有这个一个变量，定义是给这个变量赋值）；
*   2. 变量提升的细节问题：
*     2.1 变量提升不理会条件
*     2.2 变量提升只发生在当前作用域
*     2.3 变量提升只提升等号左边的
*     2.4 return右边的代码不会进行变量提升
*     2.5 return 下面的代码虽然不会执行但是仍然会进行变量提升
*     2.6 多次声明同一个变量，只声明一次，但是赋值的时候后面的会覆盖前面的。(需要特殊注意的是变量名和函数名同名的时候）
*     2.7 匿名函数没有变量提升
*   3. 带var不带var的区别：
*     3.1 带var会进行变量提升，如果是在全局声明还会给window增加一个全局属性；
*     3.2 不带var不会进行变量提升，如果赋值就会给window增加一个属性；
*     3.3 如果带var，在声明之前使用不会报错，如果不带var在赋值之前使用就会报错；
*     3.4 delete 不能删除在全局作用域中声明的变量（是因为浏览器机制把全局变量映射到上面了）
*    4. var let const的区别；var 是variable的前三个字母
*     4.1 let和const是es6新增的关键字，let用来声明变量，const用来声明常量。
*     4.2 var会变量提升，let和const不会进行变量提升；这就导致如果你是用let或者const声明变量或者常量，必须保证在使用之前声明（const还需要声明时完成定义）；
*     4.3 var声明变量可以重复声明，而let或const不可以；如果重复声明会报错：Uncaught SyntaxError：Identifier xxx has already been declared【未能捕获的语法错误：标识符 xxx 已经被声明过】
*     4.4 let 和 const会在代码块中形成块级作用域，而var不会；（for循环如果用var声明标识符，就会导致标识符代表是循环终止之后的值，因为var把这个标识符声明在全局作用域中了）
*     4.5 let和const在全局中声明的变量不会向window上增加同名属性。
*     4.6 暂时性死区得以解决，typeof不再是最安全的运算符
*     4.7 let声明的变量可以修改，const声明的基本数据类型不能修改，引用数据可以修改堆内存中的东西，但是不能修改这个堆内存地址；
*
*   5. 堆栈内存释放：
*     5.1 堆内存是存储引用数据类型值的，栈内存是js代码执行的环境、存储基本数据类型值；
*     5.2 堆内存释放：将变量指向null，等到浏览器主线程空闲的时候就会进行垃圾回收，这块堆内存就被释放；（IE浏览器采用引用计数，等到计数为0的时候就回收这块堆内存）
*     5.3 栈内存：函数执行就会新开栈内存，一般情况下函数执行完，栈内存随即销毁；但是当函数中的某一部分被外界占用，此时这个栈内存不能被销毁；
*
*   6. 作用域链：是变量查找，当我们使用一个变量的时候先看当前作用域中是否有这个变量，如果有就使用当前作用域中的变量，如果没有就向上级作用域查找，一直找到window位置，如果还没有就会报错：Uncaught ReferenceError: b is not defined 【未能捕获的引用错误】：b 没有定义
*   7. 函数执行执行形成的作用域就是闭包；保护私有变量不受外界干扰；
*   function () {
*   // 这个只是闭包一种情况而已
*     return function () {}
*   }
*/
/* 面向对象 */

/*
* 面向对象：
*   1. 对象、类、实例三者之间关系
*   对象：js中万物皆对象。对象是封装了很多属性和方法用来存储或者我们调用
*   类：根据事物的特性和特点描述一类事物。
*   实例：是类当中的一个具体事例；
*
*   2. 创建对象的方式（单例模式、高级单例、工厂模式、构造函数...）
*
*   3. 原型、类、实例三者之间的关系
*     3.1 每一个类都是一个函数数据类型，天生自带一个prototype属性；
*     3.2 每一个prototype是对象数据类型的值，天生自带两个属性：constructor，指向当前函数（类）本身;__proto__：指向原型对象自身所属类的原型；
*     3.3 实例也是对象数据类型，也有一个天生自带的属性__proto__ 指向当前实例所属类的原型；
*   4. 原型链：对象属性的查找机制。当我们访问一个对象的属性时，会先在自身的私有属性中查找，如果找到就用私有的属性，如果找不到就会通过__proto__去对象所属类原型上查找，如果找到就使用，找不到就会一直向上查找，一直找到Object.prototype为止，如果没有就返回undefined
*   5. this的问题
*     5.1 事件函数中的this指向绑定当前事件的元素；
*     5.2 自执行函数、定时器、全局作用域中的this是window
*     5.3 箭头函数中this是箭头函数声明时所在作用域中this
*     5.4 方法执行时this的指向，看有没有点，有. 点前面是谁this就是谁，如果没有就是window
*     5.5 构造函数中的this指向当前构造函数的实例；
*     5.6 call、bind、apply用于修改this指向；
*
*   6. 继承
*     6.1 原型链继承
*     6.2 call继承
*     6.3 组合继承
*     6.4 原型式继承
*     6.5 寄生组合式继承
*     6.6 extend
*     6.7 冒充对象
*     ... (除了extend至少说出四种）
*   7. 函数三种角色：普通对象、函数、类
*   8. call、apply、bind三者区别
*
* */

/* 正则 */
/*
* 正则：处理字符串规则：匹配和捕获：
*   1. 特殊元字符：
*   2. 量词元字符：
*   3. 普通元字符
*   4. 修饰符：i m g
*   5. []细节：
*     5.1 出现在其中的特殊元字符有可能变成普通元字符
*     5.2 连续出现的两个数字，表示两个当中的一个，不识别多位数
*     5.3 0-9 a-z可以，反过来写不可以
*   6. () 小括号细节
*     6.1 改变优先级；
*     6.2 分组捕获（?:取消分组）
*   7. 正则匹配test方法
*   8. 正则捕获exec，贪婪性（量词元字符后?）和懒惰性（g可以解决）
*   9. replace/match ...
*
*
* */

/* 盒子模型 */
/*
* js盒子模型：
*   1. client系列
*     clientWidth：内容宽度+左右padding
*     clientHeight：内容高度+上下padding
*     clientLeft：左边框宽度
*     clientTop：上边框宽度
*
*   2. offset系列
*     offsetWidth: clientWidth + 左右边框
*     offsetHeight： clientHeight + 上线边框
*     offsetLeft：距离父参照物左偏移量
*     offsetTop：距离父参照物的上偏移量
*     【offset方法需要掌握】
*
*
*   3. scroll系列
*     scrollWidth：包含滚动条卷去的距离的宽度
*     scrollHeight：包含滚动条卷去的距离的高度
*     scrollLeft：横向滚动条卷去的距离
*     scrollTop：纵向滚动条卷去的距离
*
*   4. 获取元素计算生效的样式：window.getComputedStyle(对象, 伪类) 返回一个对象；IE低版本有一个 元素.currentStyle 【currentStyle是元素对象的属性，不是方法】
*
*   5. 图片懒加载（包括计算何时图片出现在浏览器可视窗口内）
*
*   6. getCss、setCss、css、以及操作className的方法
*
*   7. 瀑布流【函数节流和防抖】
*
*   8. 动画思想 animate.js 库；做动画一定要想好什么时候清除定时器；
*
* */

/* 事件 */

/*
* 事件：
*   1. 鼠标事件
*     mousedown
*     mouseup
*     click
*     dbclick
*     oncontextmenu（鼠标右键）
*     mousemove
*     mouseenter
*     mouseleave
*     mouseover
*     mouseout
*   2. mouseenter、mouseleave、mouseover、mouseout
*     2.1 关于冒泡
*     2.2 从父元素进入子元素不会触发父元素的leave事件，但是会触发mouseout事件
*   3. 键盘事件：靠键码区分按下的是哪一个
*     keydown
*     keyup
*     keypress
*   4. 事件对象
*     clineX、clientY 鼠标距离浏览器可视区的x、y轴坐标
*     pageX、pageY 鼠标相对于body的x、y轴坐标
*     keyCode 键盘按下键的键码
*     target 事件目标
*   5. 阻止默认行为、阻止冒泡
*     阻止默认行为：标准：preventDefault() IE：e.returnValue = false
*     阻止冒泡：         stopPropagation() IE: e.cancelBubble = true
*   6. 事件委托：利用事件冒泡把事件绑定给高层级的元素，结合e.target判断事件源是谁
*   7. DOM0和DOM2的区别：
*     7.1 DOM0只能绑定一个，而且只能绑在冒泡
*     7.2 DOM2可以绑多个，还可以绑在捕获阶段
*   8. 标准和IE的DOM2
*     8.1 addEventListener/ removeEventListener()
*     8.2 attachEvent() / detachEvent() 且IE只能绑在冒泡
*   9. 拖拽、放大镜 => 鼠标跟随
*   10. 弹性势能动画（做了解）
*   11. 发布订阅模式
*
*
* */